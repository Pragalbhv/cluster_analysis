"""
OVITO-based Voronoi utilities mirroring the public API of `voronoi_utils.py`.

This module replaces freud-based tessellations with OVITO's
`VoronoiAnalysisModifier` and returns equivalent data structures so existing
analysis/plotting code can be reused with minimal changes.

Key differences vs freud implementation:
- Voronoi neighbors are obtained from bonds generated by
  `VoronoiAnalysisModifier(generate_bonds=True)`.
- Facet areas are read from bond property "Face area" (fallback: "Face Area").
- The `edge_threshold` modifier option (edge length) is exposed but optional;
  filtering primarily uses `min_area` after computation to match freud's API.
"""

from __future__ import annotations

from collections import Counter, defaultdict
from typing import Any, Dict, Iterable, List, Optional, Tuple

import numpy as np

try:
    import networkx as nx
except Exception as exc:  # pragma: no cover
    raise ImportError("voronoi_ovito_utils requires networkx to be installed") from exc

try:
    # OVITO 3.x Python API
    from ovito.modifiers import VoronoiAnalysisModifier
    from ovito.pipeline import Pipeline, PythonSource
    from ovito.data import Particles, SimulationCell
except Exception as exc:  # pragma: no cover
    raise ImportError(
        "voronoi_ovito_utils requires ovito to be installed (pip install ovito)"
    ) from exc


# Optional plotting utilities (reused for consistency)
try:
    from plot_utils import (
        plot_coordination_histograms as _plot_coordination_histograms,
        plot_graph_structure as _plot_graph_structure,
        plot_cluster_size_distribution as _plot_cluster_size_distribution,
        plot_cluster_composition_analysis as _plot_cluster_composition_analysis,
        plot_3d_cluster_visualization as _plot_3d_cluster_visualization,
        plot_3d_cluster_with_graph as _plot_3d_cluster_with_graph,
        analyze_bond_network as _analyze_bond_network,  # OVITO bonds (not Voronoi)
    )
except Exception:
    _plot_coordination_histograms = None  # type: ignore
    _plot_graph_structure = None  # type: ignore
    _plot_cluster_size_distribution = None  # type: ignore
    _plot_cluster_composition_analysis = None  # type: ignore
    _plot_3d_cluster_visualization = None  # type: ignore
    _plot_3d_cluster_with_graph = None  # type: ignore
    _analyze_bond_network = None  # type: ignore


# -----------------------------
# Internal helpers
# -----------------------------

def _build_ovito_pipeline_from_arrays(
    positions: np.ndarray,
    cell_matrix: np.ndarray,
    pbc: Tuple[bool, bool, bool] = (True, True, True),
    radii: Optional[np.ndarray] = None,
) -> Pipeline:
    """Create an OVITO pipeline from raw arrays using PythonSource."""

    positions = np.asarray(positions, dtype=float)
    cell_matrix = np.asarray(cell_matrix, dtype=float)
    if positions.ndim != 2 or positions.shape[1] != 3:
        raise ValueError("positions must be shape (N,3)")
    # Normalize cell to 3x4 for OVITO SimulationCell
    if cell_matrix.shape == (3, 4):
        cell34 = cell_matrix
    elif cell_matrix.shape == (3, 3):
        cell34 = np.hstack([cell_matrix, np.zeros((3, 1), dtype=cell_matrix.dtype)])
    elif cell_matrix.shape == (4, 4):
        cell34 = cell_matrix[:3, :4]
    else:
        raise ValueError("cell_matrix must be shape (3,3), (3,4) or (4,4)")

    def data_function(frame: int, data):
        cell = SimulationCell(pbc=pbc)
        cell.matrix = cell34
        data.cell = cell
        particles = Particles(count=int(positions.shape[0]))
        particles.create_property("Position", data=positions)
        if radii is not None:
            particles.create_property("Radius", data=np.asarray(radii, dtype=float))
        data.particles = particles

    return Pipeline(source=PythonSource(function=data_function))


def _compute_voronoi(
    positions: np.ndarray,
    cell_matrix: np.ndarray,
    pbc: Tuple[bool, bool, bool] = (True, True, True),
    use_radii: bool = False,
    radii: Optional[np.ndarray] = None,
    edge_threshold: float = 0.0,
):
    """Run OVITO Voronoi analysis and return the computed DataCollection."""
    pipeline = _build_ovito_pipeline_from_arrays(positions, cell_matrix, pbc=pbc, radii=(radii if use_radii else None))
    voro = VoronoiAnalysisModifier(
        compute_indices=True,
        generate_bonds=True,
        use_radii=bool(use_radii),
        edge_threshold=float(edge_threshold),
    )
    pipeline.modifiers.append(voro)
    return pipeline.compute()


def _extract_bond_pairs_and_areas(data) -> Tuple[np.ndarray, np.ndarray]:
    """Return (pairs Nx2 int, face_areas N float) from OVITO DataCollection."""
    parts = getattr(data, "particles", None)
    bonds = getattr(parts, "bonds", None) if parts is not None else None
    if bonds is None or len(bonds) == 0:
        return np.empty((0, 2), dtype=int), np.empty((0,), dtype=float)

    # Topology (pairs)
    if "Topology" in bonds:
        pairs = np.array(bonds["Topology"].array, dtype=int)
        if pairs.ndim == 1:
            pairs = pairs.reshape(-1, 2)
    elif hasattr(bonds, "topology"):
        pairs = np.array(bonds.topology, dtype=int)
    elif hasattr(bonds, "pairs"):
        pairs = np.array(bonds.pairs, dtype=int)
    else:
        pairs = np.empty((0, 2), dtype=int)

    # Face area property (name can vary slightly)
    if "Face area" in bonds:
        areas = np.asarray(bonds["Face area"].array, dtype=float)
    elif "Face Area" in bonds:
        areas = np.asarray(bonds["Face Area"].array, dtype=float)
    elif "Voronoi Face Area" in bonds:
        areas = np.asarray(bonds["Voronoi Face Area"].array, dtype=float)
    else:
        # Fallback: zeros if not available
        areas = np.zeros(len(pairs), dtype=float)

    return pairs, areas


# Helper: extract particle names (species) from OVITO DataCollection
def _names_from_data_particles(parts) -> np.ndarray:
    if parts is None:
        return np.array([], dtype=object)
    # Prefer Particle Type mapping if present
    if "Particle Type" in parts:
        types_prop = parts["Particle Type"]
        types = parts.particle_types
        return np.array([types.type_by_id(t).name for t in types_prop], dtype=object)
    # Fallback: check for explicit "Name" property
    if "Name" in parts:
        return np.array(list(parts["Name"].array), dtype=object)
    # As a last resort, return empty names
    return np.array(["X"] * len(parts), dtype=object)


# -----------------------------
# Voronoi graph construction
# -----------------------------

def build_voronoi_graph(
    atoms: Any,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> nx.Graph:
    """Build a Voronoi graph for all atoms using OVITO.

    Nodes include attributes: `position`, `species`, `index`.
    Edges include attributes: `area` (facet area) and `species_pair`.
    """
    assert atoms.pbc.all(), "OVITO Voronoi expects PBC in all directions."

    positions = atoms.get_positions()
    species = atoms.get_chemical_symbols()
    cell_matrix = atoms.get_cell().array
    # Ensure 3x3 for internal pipeline creation
    if cell_matrix.shape == (3, 4):
        cell_matrix = cell_matrix[:, :3]
    elif cell_matrix.shape == (4, 4):
        cell_matrix = cell_matrix[:3, :3]
    radii = atoms.get_array("radii") if (use_radii and "radii" in atoms.arrays) else None

    data = _compute_voronoi(
        positions=positions,
        cell_matrix=cell_matrix,
        pbc=tuple(bool(x) for x in atoms.pbc),
        use_radii=use_radii,
        radii=radii,
        edge_threshold=edge_threshold,
    )

    pairs, areas = _extract_bond_pairs_and_areas(data)
    mask = areas >= float(min_area)
    pairs = pairs[mask]
    areas = areas[mask]

    G = nx.Graph()
    for i, (pos, spec) in enumerate(zip(positions, species)):
        G.add_node(int(i), position=np.asarray(pos), species=str(spec), index=int(i))

    for (i, j), a in zip(pairs, areas):
        G.add_edge(int(i), int(j), area=float(a), species_pair=f"{species[i]}-{species[j]}")

    return G


def build_voronoi_graph_metals_only(
    atoms: Any,
    min_area: float = 0.0,
    metal_species: Iterable[str] | None = None,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> nx.Graph:
    """Build a Voronoi graph using only selected metal atoms as points using OVITO."""
    assert atoms.pbc.all(), "OVITO Voronoi expects PBC in all directions."
    if metal_species is None:
        metal_species = ["Pu", "Na"]

    all_species = atoms.get_chemical_symbols()
    positions = atoms.get_positions()
    cell_matrix = atoms.get_cell().array
    if cell_matrix.shape == (3, 4):
        cell_matrix = cell_matrix[:, :3]
    elif cell_matrix.shape == (4, 4):
        cell_matrix = cell_matrix[:3, :3]

    metal_mask = np.array([sp in set(metal_species) for sp in all_species], dtype=bool)
    metal_indices = np.where(metal_mask)[0]
    if metal_indices.size == 0:
        return nx.Graph()

    metal_positions = positions[metal_indices]
    metal_species_list = [all_species[i] for i in metal_indices]
    radii = None
    if use_radii and "radii" in atoms.arrays:
        radii = np.asarray(atoms.get_array("radii"))[metal_indices]

    data = _compute_voronoi(
        positions=metal_positions,
        cell_matrix=cell_matrix,
        pbc=tuple(bool(x) for x in atoms.pbc),
        use_radii=use_radii,
        radii=radii,
        edge_threshold=edge_threshold,
    )

    pairs, areas = _extract_bond_pairs_and_areas(data)
    mask = areas >= float(min_area)
    pairs = pairs[mask]
    areas = areas[mask]

    G = nx.Graph()
    for idx_in_subset, (pos, spec) in enumerate(zip(metal_positions, metal_species_list)):
        original_index = int(metal_indices[idx_in_subset])
        G.add_node(original_index, position=np.asarray(pos), species=str(spec), index=original_index)

    for (i_sub, j_sub), a in zip(pairs, areas):
        orig_i = int(metal_indices[int(i_sub)])
        orig_j = int(metal_indices[int(j_sub)])
        G.add_edge(orig_i, orig_j, area=float(a), species_pair=f"{metal_species_list[int(i_sub)]}-{metal_species_list[int(j_sub)]}")

    return G


# -----------------------------
# OVITO pipeline-based entry points
# -----------------------------

def build_voronoi_graph_from_pipeline(
    pipeline: Any,
    frame: int = 0,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> nx.Graph:
    """Build Voronoi graph directly from an OVITO pipeline frame."""
    # Ensure Voronoi bonds are generated for this frame
    voro = VoronoiAnalysisModifier(
        compute_indices=True,
        generate_bonds=True,
        use_radii=bool(use_radii),
        edge_threshold=float(edge_threshold),
    )
    pipeline.modifiers.append(voro)
    try:
        data = pipeline.compute(frame)
    finally:
        try:
            pipeline.modifiers.remove(voro)
        except Exception:
            pass
    parts = data.particles
    names = _names_from_data_particles(parts)
    pos = np.asarray(parts.positions)

    pairs, areas = _extract_bond_pairs_and_areas(data)
    mask = areas >= float(min_area)
    pairs = pairs[mask]
    areas = areas[mask]

    G = nx.Graph()
    for i, (p, spec) in enumerate(zip(pos, names)):
        G.add_node(int(i), position=np.asarray(p), species=str(spec), index=int(i))
    for (i, j), a in zip(pairs, areas):
        G.add_edge(int(i), int(j), area=float(a), species_pair=f"{names[int(i)]}-{names[int(j)]}")
    return G


def build_voronoi_graph_metals_only_from_pipeline(
    pipeline: Any,
    frame: int = 0,
    min_area: float = 0.0,
    metal_species: Iterable[str] | None = None,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> nx.Graph:
    """Build metals-only Voronoi graph from an OVITO pipeline frame."""
    if metal_species is None:
        metal_species = ["Pu", "Na"]

    data = pipeline.compute(frame)
    cell = np.asarray(data.cell.matrix).copy()
    if cell.shape == (3, 4):
        cell = cell[:, :3]
    elif cell.shape == (4, 4):
        cell = cell[:3, :3]
    pbc = tuple(bool(x) for x in data.cell.pbc)
    parts = data.particles
    names = _names_from_data_particles(parts)
    pos = np.asarray(parts.positions)

    metal_mask = np.isin(names, list(metal_species))
    metal_indices = np.where(metal_mask)[0]
    if metal_indices.size == 0:
        return nx.Graph()
    metal_positions = pos[metal_indices]
    metal_names = names[metal_indices]

    radii = None
    if use_radii and "Radius" in parts:
        radii = np.asarray(parts["Radius"].array)[metal_indices]

    ovito_data = _compute_voronoi(
        positions=metal_positions,
        cell_matrix=cell,
        pbc=pbc,
        use_radii=use_radii,
        radii=radii,
        edge_threshold=edge_threshold,
    )
    pairs, areas = _extract_bond_pairs_and_areas(ovito_data)
    mask = areas >= float(min_area)
    pairs = pairs[mask]
    areas = areas[mask]

    G = nx.Graph()
    for idx_in_subset, (p, spec) in enumerate(zip(metal_positions, metal_names)):
        original_index = int(metal_indices[idx_in_subset])
        G.add_node(original_index, position=np.asarray(p), species=str(spec), index=original_index)
    for (i_sub, j_sub), a in zip(pairs, areas):
        oi = int(metal_indices[int(i_sub)])
        oj = int(metal_indices[int(j_sub)])
        G.add_edge(oi, oj, area=float(a), species_pair=f"{metal_names[int(i_sub)]}-{metal_names[int(j_sub)]}")
    return G


def analyze_voronoi_coordination_from_pipeline(
    pipeline: Any,
    frames: Optional[List[int]] = None,
    at_list: Optional[Iterable[str]] = None,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Dict[str, Dict[str, List[int]]]:
    """Compute neighbor-count distributions by species using an OVITO pipeline.

    frames: list of frame indices to include; defaults to all frames.
    """
    nframes = pipeline.source.num_frames if hasattr(pipeline, "source") else 1
    if frames is None:
        frames = list(range(nframes))

    # Prepare voronoi modifier once and remove after
    voro = VoronoiAnalysisModifier(
        compute_indices=True,
        generate_bonds=True,
        use_radii=bool(use_radii),
        edge_threshold=float(edge_threshold),
    )
    pipeline.modifiers.append(voro)
    try:
        # Determine species universe
        if at_list is None:
            species_set = set()
            for fr in frames:
                d = pipeline.compute(fr)
                names = _names_from_data_particles(d.particles)
                species_set.update(names.tolist())
            all_species = sorted(species_set)
        else:
            all_species = list(at_list)

        sp2idx = {sp: i for i, sp in enumerate(all_species)}
        coord_data: Dict[str, Dict[str, List[int]]] = {sp_c: {sp_n: [] for sp_n in all_species} for sp_c in all_species}

        for fr in frames:
            data = pipeline.compute(fr)
            parts = data.particles
            names = _names_from_data_particles(parts)
            species_idx = np.array([sp2idx.get(s, -1) for s in names], dtype=int)

            pairs, areas = _extract_bond_pairs_and_areas(data)
            mask = areas >= float(min_area)
            pairs = pairs[mask]

            N = len(names)
            S = len(all_species)
            counts = np.zeros((N, S), dtype=int)
            if pairs.size:
                i = pairs[:, 0]
                j = pairs[:, 1]
                valid_i = (species_idx[i] >= 0)
                valid_j = (species_idx[j] >= 0)
                valid = valid_i & valid_j
                i = i[valid]
                j = j[valid]
                np.add.at(counts, (i, species_idx[j]), 1)
                np.add.at(counts, (j, species_idx[i]), 1)

            for sp_c, c_idx in sp2idx.items():
                rows = np.where(species_idx == c_idx)[0]
                if rows.size == 0:
                    continue
                sub = counts[rows]
                for sp_n, n_idx in sp2idx.items():
                    coord_data[sp_c][sp_n].extend(sub[:, n_idx].tolist())

        return coord_data
    finally:
        try:
            pipeline.modifiers.remove(voro)
        except Exception:
            pass


def analyze_temporal_graph_properties_from_pipeline(
    pipeline: Any,
    frames: Optional[List[int]] = None,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Dict[str, Any]:
    """Temporal graph properties over selected frames using OVITO pipeline."""
    nframes = pipeline.source.num_frames if hasattr(pipeline, "source") else 1
    if frames is None:
        frames = list(range(nframes))

    temporal: Dict[str, Any] = {
        "frame_indices": np.array(frames, dtype=int),
        "num_nodes": [],
        "num_edges": [],
        "density": [],
        "avg_degree": [],
        "is_connected": [],
        "largest_component_fraction": [],
        "avg_facet_area": [],
    }

    for fr in frames:
        G = build_voronoi_graph_from_pipeline(
            pipeline,
            frame=fr,
            min_area=min_area,
            use_radii=use_radii,
            edge_threshold=edge_threshold,
        )
        props = analyze_graph_properties(G)

        temporal["num_nodes"].append(props.get("num_nodes", 0))
        temporal["num_edges"].append(props.get("num_edges", 0))
        temporal["density"].append(props.get("density", 0.0))
        temporal["avg_degree"].append(props.get("avg_degree", 0.0))
        temporal["is_connected"].append(props.get("is_connected", False))
        temporal["largest_component_fraction"].append(props.get("largest_component_fraction", 1.0))
        temporal["avg_facet_area"].append(props.get("avg_facet_area", 0.0))

    return temporal


# -----------------------------
# Coordination analysis
# -----------------------------

def analyze_voronoi_coordination(
    atoms_list: List[Any],
    at_list: Optional[Iterable[str]] = None,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Dict[str, Dict[str, List[int]]]:
    """Compute neighbor-count distributions by species using OVITO Voronoi bonds."""
    if at_list is None:
        all_species = sorted({s for at in atoms_list for s in at.get_chemical_symbols()})
    else:
        all_species = list(at_list)

    sp2idx = {sp: i for i, sp in enumerate(all_species)}
    coord_data: Dict[str, Dict[str, List[int]]] = {sp_c: {sp_n: [] for sp_n in all_species} for sp_c in all_species}

    for atoms in atoms_list:
        assert atoms.pbc.all(), "OVITO Voronoi expects PBC in all directions."
        positions = atoms.get_positions()
        species = np.array(atoms.get_chemical_symbols())
        species_idx = np.array([sp2idx[s] for s in species], dtype=int)

        radii = atoms.get_array("radii") if (use_radii and "radii" in atoms.arrays) else None
        data = _compute_voronoi(
            positions=positions,
            cell_matrix=atoms.get_cell().array,
            pbc=tuple(bool(x) for x in atoms.pbc),
            use_radii=use_radii,
            radii=radii,
            edge_threshold=edge_threshold,
        )

        pairs, areas = _extract_bond_pairs_and_areas(data)
        mask = areas >= float(min_area)
        pairs = pairs[mask]

        N = len(atoms)
        S = len(all_species)
        counts = np.zeros((N, S), dtype=int)
        if pairs.size:
            i = pairs[:, 0]
            j = pairs[:, 1]
            np.add.at(counts, (i, species_idx[j]), 1)
            np.add.at(counts, (j, species_idx[i]), 1)

        for sp_c, c_idx in sp2idx.items():
            rows = np.where(species_idx == c_idx)[0]
            if rows.size == 0:
                continue
            sub = counts[rows]
            for sp_n, n_idx in sp2idx.items():
                coord_data[sp_c][sp_n].extend(sub[:, n_idx].tolist())

    return coord_data


def analyze_voronoi_coordination_metals_only(
    atoms_list: List[Any],
    metal_species: Iterable[str] | None = None,
    min_area: float = 0.0,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Dict[str, Dict[str, List[int]]]:
    """Coordination distributions restricted to selected metal species using OVITO."""
    if metal_species is None:
        metal_species = ["Pu", "Na"]

    metals = list(metal_species)
    coord_data: Dict[str, Dict[str, List[int]]] = {sp_c: {sp_n: [] for sp_n in metals} for sp_c in metals}

    for atoms in atoms_list:
        assert atoms.pbc.all(), "OVITO Voronoi expects PBC in all directions."
        all_species = atoms.get_chemical_symbols()
        positions = atoms.get_positions()

        metal_mask = np.array([sp in set(metals) for sp in all_species], dtype=bool)
        metal_indices = np.where(metal_mask)[0]
        if metal_indices.size == 0:
            continue

        metal_positions = positions[metal_indices]
        metal_species_list = [all_species[i] for i in metal_indices]
        radii = None
        if use_radii and "radii" in atoms.arrays:
            radii = np.asarray(atoms.get_array("radii"))[metal_indices]

        data = _compute_voronoi(
            positions=metal_positions,
            cell_matrix=atoms.get_cell().array,
            pbc=tuple(bool(x) for x in atoms.pbc),
            use_radii=use_radii,
            radii=radii,
            edge_threshold=edge_threshold,
        )

        pairs, areas = _extract_bond_pairs_and_areas(data)
        mask = areas >= float(min_area)
        pairs = pairs[mask]

        N = metal_indices.size
        S = len(metals)
        counts = np.zeros((N, S), dtype=int)
        if pairs.size:
            i = pairs[:, 0]
            j = pairs[:, 1]
            sp_idx = np.array([metals.index(s) for s in metal_species_list], dtype=int)
            np.add.at(counts, (i, sp_idx[j]), 1)
            np.add.at(counts, (j, sp_idx[i]), 1)

        for i_center, central_spec in enumerate(metal_species_list):
            for n_idx, neighbor_spec in enumerate(metals):
                coord_data[central_spec][neighbor_spec].append(int(counts[i_center, n_idx]))

    return coord_data


# -----------------------------
# Graph properties and temporal evolution
# -----------------------------

def analyze_graph_properties(G: nx.Graph, species_filter: Optional[Iterable[str]] = None) -> Dict[str, Any]:
    """Summarize graph properties useful for personality analysis."""
    properties: Dict[str, Any] = {}

    if species_filter is not None:
        allowed = set(species_filter)
        nodes_to_keep = [n for n in G.nodes if G.nodes[n].get("species") in allowed]
        G = G.subgraph(nodes_to_keep).copy()

    properties["num_nodes"] = G.number_of_nodes()
    properties["num_edges"] = G.number_of_edges()
    properties["density"] = nx.density(G) if G.number_of_nodes() > 1 else 0.0

    species_counts: Dict[str, int] = defaultdict(int)
    for node in G.nodes:
        species_counts[G.nodes[node]["species"]] += 1
    properties["species_counts"] = dict(species_counts)

    if properties["num_nodes"] > 0 and nx.is_connected(G):
        properties["is_connected"] = True
        properties["diameter"] = nx.diameter(G)
        properties["radius"] = nx.radius(G)
    else:
        properties["is_connected"] = False
        properties["num_components"] = nx.number_connected_components(G) if G.number_of_nodes() > 0 else 0
        if G.number_of_nodes() > 0:
            largest_cc = max(nx.connected_components(G), key=len)
            properties["largest_component_size"] = len(largest_cc)
            properties["largest_component_fraction"] = len(largest_cc) / G.number_of_nodes()

    if properties["num_nodes"] > 0:
        degrees = [G.degree(n) for n in G.nodes]
        properties["avg_degree"] = float(np.mean(degrees)) if degrees else 0.0
        properties["std_degree"] = float(np.std(degrees)) if degrees else 0.0
        properties["max_degree"] = int(max(degrees)) if degrees else 0
        properties["min_degree"] = int(min(degrees)) if degrees else 0

        species_degrees: Dict[str, List[int]] = defaultdict(list)
        for node in G.nodes:
            species_degrees[str(G.nodes[node]["species"])].append(G.degree(node))
        properties["species_avg_degrees"] = {sp: float(np.mean(d)) for sp, d in species_degrees.items() if d}

        if G.number_of_edges() > 0:
            edge_areas = [G.edges[e].get("area", 0.0) for e in G.edges]
            properties["avg_facet_area"] = float(np.mean(edge_areas)) if edge_areas else 0.0
            properties["std_facet_area"] = float(np.std(edge_areas)) if edge_areas else 0.0
            properties["min_facet_area"] = float(np.min(edge_areas)) if edge_areas else 0.0
            properties["max_facet_area"] = float(np.max(edge_areas)) if edge_areas else 0.0
        else:
            properties["avg_facet_area"] = properties["std_facet_area"] = 0.0
            properties["min_facet_area"] = properties["max_facet_area"] = 0.0

    return properties


def analyze_temporal_graph_properties(
    atoms_list: List[Any],
    min_area: float = 0.0,
    sample_frames: int = 10,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Dict[str, Any]:
    """Compute temporal evolution of selected graph properties using OVITO Voronoi."""
    frame_indices = np.linspace(0, len(atoms_list) - 1, sample_frames, dtype=int)

    temporal: Dict[str, Any] = {
        "frame_indices": frame_indices,
        "num_nodes": [],
        "num_edges": [],
        "density": [],
        "avg_degree": [],
        "is_connected": [],
        "largest_component_fraction": [],
        "avg_facet_area": [],
    }

    for frame_idx in frame_indices:
        atoms = atoms_list[frame_idx]
        G = build_voronoi_graph(atoms, min_area=min_area, use_radii=use_radii, edge_threshold=edge_threshold)
        props = analyze_graph_properties(G)

        temporal["num_nodes"].append(props.get("num_nodes", 0))
        temporal["num_edges"].append(props.get("num_edges", 0))
        temporal["density"].append(props.get("density", 0.0))
        temporal["avg_degree"].append(props.get("avg_degree", 0.0))
        temporal["is_connected"].append(props.get("is_connected", False))
        temporal["largest_component_fraction"].append(props.get("largest_component_fraction", 1.0))
        temporal["avg_facet_area"].append(props.get("avg_facet_area", 0.0))

    return temporal


def plot_temporal_graph_properties(temporal: Dict[str, Any]) -> None:
    import matplotlib.pyplot as plt

    idx = np.arange(len(temporal.get("frame_indices", [])))

    plt.figure(figsize=(12, 8))
    ax1 = plt.subplot(2, 2, 1)
    ax1.plot(idx, temporal.get("density", []), label="density")
    ax1.set_title("Graph density over time")
    ax1.grid(True, alpha=0.3)

    ax2 = plt.subplot(2, 2, 2)
    ax2.plot(idx, temporal.get("avg_degree", []), label="avg_degree", color="tab:orange")
    ax2.set_title("Average degree over time")
    ax2.grid(True, alpha=0.3)

    ax3 = plt.subplot(2, 2, 3)
    ax3.plot(idx, temporal.get("num_edges", []), label="#edges", color="tab:green")
    ax3.set_title("Edges over time")
    ax3.grid(True, alpha=0.3)

    ax4 = plt.subplot(2, 2, 4)
    ax4.plot(idx, temporal.get("avg_facet_area", []), label="avg_facet_area", color="tab:red")
    ax4.set_title("Avg facet area over time")
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


# -----------------------------
# Clusters on metals-only graphs
# -----------------------------

def analyze_voronoi_clusters(
    atoms: Any,
    min_area: float = 0.0,
    metal_species: Iterable[str] | None = None,
    use_radii: bool = False,
    edge_threshold: float = 0.0,
) -> Tuple[np.ndarray, np.ndarray, nx.Graph]:
    """Cluster analysis using metals-only Voronoi graph (OVITO)."""
    if metal_species is None:
        metal_species = ["Pu", "Na"]

    G = build_voronoi_graph_metals_only(
        atoms, min_area=min_area, metal_species=metal_species, use_radii=use_radii, edge_threshold=edge_threshold
    )
    if G.number_of_nodes() == 0:
        return np.array([], dtype=int), -np.ones(len(atoms), dtype=int), G

    components = list(nx.connected_components(G))
    cluster_sizes = np.array([len(comp) for comp in components], dtype=int)
    cluster_ids = -np.ones(len(atoms), dtype=int)

    for cid, comp in enumerate(components):
        for atom_idx in comp:
            cluster_ids[int(atom_idx)] = int(cid)

    return cluster_sizes, cluster_ids, G


# -----------------------------
# Voronoi edge/bond summaries
# -----------------------------

def summarize_voronoi_edge_network(G: nx.Graph, plot: bool = True) -> Counter:
    """Count Voronoi edges by species pair and optionally plot a bar chart."""
    import matplotlib.pyplot as plt

    pair_counts: Counter = Counter()
    for u, v, data in G.edges(data=True):
        su = str(G.nodes[u].get("species"))
        sv = str(G.nodes[v].get("species"))
        key = tuple(sorted([su, sv]))
        pair_counts[key] += 1

    if plot and pair_counts:
        labels = [f"{a}-{b}" for (a, b) in pair_counts.keys()]
        values = list(pair_counts.values())

        plt.figure(figsize=(10, 5))
        bars = plt.bar(labels, values, alpha=0.8)
        plt.xlabel("Voronoi edge pair")
        plt.ylabel("Count")
        plt.title("Voronoi Edge Network Summary (OVITO)")
        plt.xticks(rotation=45)
        for bar, value in zip(bars, values):
            plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.1, str(value), ha="center", va="bottom")
        plt.tight_layout()
        plt.show()

    if pair_counts:
        print("Voronoi Edge Network Summary (OVITO):")
        for (a, b), count in pair_counts.items():
            print(f"{a}-{b}: {count} edges")

    return pair_counts


# -----------------------------
# Thin plotting wrappers (optional)
# -----------------------------

def plot_coordination_histograms(coord_data: Dict[str, Dict[str, List[int]]], central_type: str) -> None:
    if _plot_coordination_histograms is None:
        raise ImportError("plot_utils is required for plotting coordination histograms")
    _plot_coordination_histograms(coord_data, central_type)


def plot_graph_structure(G: nx.Graph, title: str = "Voronoi Graph Structure (OVITO)") -> None:
    if _plot_graph_structure is None:
        raise ImportError("plot_utils is required for graph plotting")
    _plot_graph_structure(G, title)


def plot_cluster_size_distribution(sizes: List[int], title: str = "Cluster Size Distribution (OVITO)") -> None:
    if _plot_cluster_size_distribution is None:
        raise ImportError("plot_utils is required for plotting cluster size distribution")
    _plot_cluster_size_distribution(sizes, title)


def plot_cluster_composition_analysis(data: Any, cluster_ids: np.ndarray, names: np.ndarray) -> List[dict]:
    if _plot_cluster_composition_analysis is None:
        raise ImportError("plot_utils is required for plotting cluster composition")
    return _plot_cluster_composition_analysis(data, cluster_ids, names)


def plot_3d_cluster_visualization(data: Any, cluster_ids: np.ndarray, names: np.ndarray, max_clusters: int = 10) -> None:
    if _plot_3d_cluster_visualization is None:
        raise ImportError("plot_utils is required for 3D plotting")
    _plot_3d_cluster_visualization(data, cluster_ids, names, max_clusters=max_clusters)


def plot_3d_cluster_with_graph(data: Any, cluster_ids: np.ndarray, names: np.ndarray, G: Optional[Any], max_clusters: int = 10) -> None:
    if _plot_3d_cluster_with_graph is None:
        raise ImportError("plot_utils is required for 3D plotting")
    _plot_3d_cluster_with_graph(data, cluster_ids, names, G, max_clusters=max_clusters)


def analyze_bond_network_via_ovito(data: Any, names: np.ndarray) -> Counter:
    if _analyze_bond_network is None:
        raise ImportError("plot_utils.analyze_bond_network is unavailable")
    return _analyze_bond_network(data, names)


# -----------------------------
# Helpers
# -----------------------------

def extract_info(path: str) -> Tuple[Optional[float], Optional[int]]:
    import re

    match = re.search(r"NaCl-PuCl3/x(\d*\.?\d+)/T(\d+)K/", path)
    if match:
        x = float(match.group(1))
        temperature = int(match.group(2))
        return x, temperature
    return None, None


__all__ = [
    # graph/build
    "build_voronoi_graph",
    "build_voronoi_graph_metals_only",
    # coordination
    "analyze_voronoi_coordination",
    "analyze_voronoi_coordination_metals_only",
    # properties & temporal
    "analyze_graph_properties",
    "analyze_temporal_graph_properties",
    "plot_temporal_graph_properties",
    # clusters
    "analyze_voronoi_clusters",
    # edge/bond summaries
    "summarize_voronoi_edge_network",
    "analyze_bond_network_via_ovito",
    # wrappers
    "plot_coordination_histograms",
    "plot_graph_structure",
    "plot_cluster_size_distribution",
    "plot_cluster_composition_analysis",
    "plot_3d_cluster_visualization",
    "plot_3d_cluster_with_graph",
    # helpers
    "extract_info",
]


